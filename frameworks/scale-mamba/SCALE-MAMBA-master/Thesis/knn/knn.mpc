import csv
import numpy as np
import sys

from Compiler.program import Program

program.set_bit_length(22)
program.set_security(100)

sys.setrecursionlimit(1000000)

n_total_runs = 1
n_threads = 1
multithread_tree = True

value_type = sfix


def load_raw_data():
    def open_csv(path):
        return np.genfromtxt(path, delimiter=',')
    #    with open(path, 'r') as csvfile:
    #        reader = csv.reader(csvfile, delimiter=',')
    #        reader_list = list(reader)
    #        csv_out = numpy.array(reader_list)
    #        return csv_out

    folder_path = "./Thesis/knn/"
    training_vectors_path = folder_path + "training_vec" + ".csv"
    training_classes_path = folder_path + "training_classes" + ".csv"
    testing_vectors_path = folder_path + "testing_vec" + ".csv"

    training_vec = open_csv(training_vectors_path).astype("float")
    training_classes = open_csv(training_classes_path).astype("int")
    testing_vec = open_csv(testing_vectors_path).astype("float")

    return training_vec, training_classes, testing_vec


training_vec, training_classes, testing_vec = load_raw_data()

n_samples = int(len(training_vec))
feature_size = len(testing_vec)
n_classes = int(max(training_classes))
samples = value_type.Matrix(n_samples, feature_size)
classes = value_type.Array(n_samples)
test = value_type.Array(feature_size)


def assign_type_value(val):
    if value_type is sfix:
        return sfix(float(val))
    elif value_type is sint:
        return sint(int(val))


def load_training():
    for i in range(n_samples):
        classes[i] = assign_type_value(training_classes[i])  # input targets

    for i in range(n_samples):
        for j in range(feature_size):
            samples[i][j] = assign_type_value(
                training_vec[i][j])  # input features


def load_testing():
    for i in range(feature_size):
        test[i] = assign_type_value(
            testing_vec[i])  # input features


load_training()
load_testing()


def print_vector(vec1, vec2):
    @for_range(len(vec1))
    def f(i):
        print_ln('Vector value: %s and %s', vec2[i].reveal(), vec1[i].reveal())


def tree_arg_max_outer(a, b):
    def tree_arg_max(seq, inds):
        n = len(seq)
        if n == 1:
            return seq[0], inds[0]
        else:
            rounded_half = (n + 1) / 2
            reduced_seq = [None for i in range(rounded_half)]
            reduced_inds = [None for i in range(rounded_half)]

            for i in range(n / 2):
                comparison_flag = seq[2 * i] < seq[2 * i + 1]
                win_val = comparison_flag.if_else(seq[2 * i], seq[2 * i + 1])
                win_ind = comparison_flag.if_else(inds[2 * i], inds[2 * i + 1])

                reduced_seq[i] = win_val
                reduced_inds[i] = win_ind
            if n % 2:
                reduced_seq[rounded_half - 1] = seq[n - 1]
                reduced_inds[rounded_half - 1] = inds[n - 1]
            return tree_arg_max(reduced_seq, reduced_inds)

    if multithread_tree is None:
        return tree_arg_max(a, b)
    else:

        last_chunk_size = len(a) % n_threads
        vals = value_type.Array(n_threads + int(last_chunk_size > 0))
        inds = value_type.Array(n_threads + int(last_chunk_size > 0))

        def thread():
            i = get_arg()
            n_per_thread = len(a) / n_threads
            start = i * n_per_thread
            chunk_vals = [a[start + j] for j in range(n_per_thread)]
            chunk_inds = [b[start + j] for j in range(n_per_thread)]
            vals[i], inds[i] = tree_arg_max(chunk_vals, chunk_inds)

        tape = program.new_tape(thread)
        threads = [program.run_tape(tape, i) for i in range(n_threads)]
        for i in threads:
            program.join_tape(i)

        if last_chunk_size > 0:
            begin = len(a) - last_chunk_size
            chunk_vals = [a[begin + j] for j in range(last_chunk_size)]
            chunk_inds = [b[begin + j] for j in range(last_chunk_size)]
            vals[n_threads], inds[n_threads] = tree_arg_max(
                chunk_vals, chunk_inds)

        return tree_arg_max(vals, inds)


class KNN(object):
    def __init__(self, samples, classes, num_samples, feature_size):
        self.num_features = feature_size
        self.num_samples = num_samples
        self.training = value_type.Matrix(num_samples, feature_size)

        @for_range(num_samples)
        def f(i):
            @for_range(feature_size)
            def g(j):
                self.training[i][j] = samples[i][j]

        self.targets = value_type.Array(num_samples)

        @for_range(num_samples)
        def f(i):
            self.targets[i] = classes[i]

    def compute_dists(self, test):
        # number of threads dependent on the number of classes
        num_features = self.num_features
        num_samples = self.num_samples
        dists = value_type.Array(num_samples)
        if num_features % n_threads:
            raise Exception(
                'Number of threads must divide the number of sample elements')

        def thread_chunk():
            i = get_arg()
            chunk_size = num_samples / n_threads
            start_chunk = i * chunk_size

            for k in range(chunk_size):
                dists[start_chunk + k] = sum((self.training[k + start_chunk]
                                              [j] - test[j])**2 for j in range(num_features))

        tape = program.new_tape(thread_chunk)  # define what function executes
        threads = [program.run_tape(tape, i) for i in range(
            n_threads)]  # execute each thread
        for i in threads:
            program.join_tape(i)  # wait until tape i has finished

        return dists

    def predict(self, test):
        dists = self.compute_dists(test)
        print_ln('Distances computed')
        result, label = tree_arg_max_outer(dists, self.targets)
        return result, label


def time_private_classifier(ntotal):
    classifier = KNN(samples, classes, n_samples, feature_size)
    cur_sample = value_type.Array(feature_size)

    start_timer(2)

    @for_range(ntotal)
    def f(i):
        result, label = classifier.predict(test)
        print_ln('##############')
        print_ln('i: %s, label: %s with dist %s',
                 i, label.reveal(), result.reveal())
    stop_timer(2)


time_private_classifier(n_total_runs)

# import ipdb; ipdb.set_trace()
